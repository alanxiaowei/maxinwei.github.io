[{"title":"RocketMQ搭建2M-2S集群","url":"/2019/06/09/RocketMQ搭建2M-2S集群/","content":"\n## 概述\n\n​\t\tRocketMQ早期为阿里巴巴消息队列开源项目，后被捐赠给apache并成为其顶级开源项目被应用到很多互联网公司系统中。消息队列本质上是一种\"先进先出\"的数据结构，RocketMQ具有应用解耦、流量消峰、消息分发、保证最终一致性，方便动态扩容等特性。另外RocketMQ使用Java语言开发，这也降低了分析源码的门槛，方便大家更深入的排查定位问题和二次定制开发。\n\n### 架构图\n\n<img src=\"RocketMQ-001.png\" height=auto width=\"90%\">\n\n​\t\tRocketMQ基于长轮序的拉取方式，这样便解决了事物消息、顺序消息和海量堆积等问题，消息队列的push和pull机制会在后续原理篇中详细说明。长连接每隔30s发送一次心跳包，如果长时间未收到心跳包Nameserver会踢掉Broker，即关闭与Broker的连接。\n\n\n### 基本概念\n\n- Nameserver——Nameserver是整个消息队列中的状态服务器，集群的各个组件通过其了解彼此信息。\t\t\n\n- Broker——消息中转角色，负责存储消息，转发消息。\n\n- Topic——消息队列分类，用来区分不同类型的消息。\n\n- Tag——消息队列子分类，用来区分相同Topic下的不同信息。\n\n- Queue——Topic对应的消息队列数，如消息需要全局顺序，则topic的queue必须设置为1。\n\n### 集群模式\n\n#### 1M1S\n\n优点: Broker-Master宕机，Broker-Slave可以同步Broker-Master未被消费的消息，供消费者消费，不中断后续业务流程。\n\n缺点:Broker- Master宕机后，生产者无法在Broker-Slave生产消息，即\"只能读消息，不能写消息\"。\n\n#### 2M\n\n优点: 一台Broker-Master-01宕机，不影响另一台，Nameserver会在30秒内，踢掉宕机Broker-Master-01，从而保证新连接的client都访问到正常Broker-Master-02。\n\n缺点: 宕机Broker-Master-01中未被消费的消息无法同步。\n\n#### 2M2S\n\n可以兼顾\"1M1S\"和\"2M\"模式的优点，宕机Broker-Master-01的消息同步后继续被消费，又可以向另一个存活的Broker-Master-02中生产新的消息。\n\n### 配置安装\n\n#### 设备信息\n\n​\t\t可以使用4台机器分别启动Namserver01和Broker-Master-01、Namserver02和Broker-Master-02、Broker-Slave-01、Broker-Slave-02，因为Nameserver压力比较小，测试只需两台构成最小集群即可。\n\n​\t\t笔者在个人mac上编写此篇博文，为了简单表明原理，通过不同端口来代表不同虚机，由于需要测试不同IP的Nameserver集群，故使用一台虚机。\n\n<style>\ntable th:first-of-type {\n\twidth: 360px;\n}\ntable th:nth-of-type(2){\n\twidth: 360px;\n}\n</style>\n\n\n|       名称       |       IP:Port       |\n| :--------------:| :-----------------: |\n|   Namserver01    | 192.168.2.134:9876 |\n| Broker-Master-01 | 192.168.2.134:10911 |\n| Broker-Slave-01  | 192.168.2.134:11012 |\n|   Namserver02    | 192.168.2.183:9876  |\n| Broker-Master-02 | 192.168.2.134:12013 |\n| Broker-Slave-02  | 192.168.2.134:13014 |\n\n#### 下载MQ\n\nhttp://rocketmq.apache.org/dowloading/releases/\n\n本文选择目前公司生产版本4.2.0 release\n\n- 解压\n\n```shell\nunzip rocketmq-all-4.2.0-bin-release.zip -d ./rocketmq-all-4.2.0-bin-release\ncd rocketmq-all-4.2.0-bin-release/\n```\n\n#### 修改内存\n\nRocketMQ默认运行需要占用4G内存，在测试环境可以根据实际需要修改内存大小，否则会出现内存不足无法启动Broker的问题。\n\n**bin/runserver.sh**\n\n修改前\n\n```shell\nJAVA_OPT=\"${JAVA_OPT} -server -Xms4g -Xmx4g -Xmn2g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m\"\n```\n\n修改后\n\n```shell\nJAVA_OPT=\"${JAVA_OPT} -server -Xms256m -Xmx256m -Xmn128m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m\"\n```\n\n**bin/runbroker.sh**\n\n修改前\n\n```shell\nJAVA_OPT=\"${JAVA_OPT} -server -Xms8g -Xmx8g -Xmn4g\"\n```\n\n修改后\n\n```shell\nJAVA_OPT=\"${JAVA_OPT} -server -Xms256m -Xmx256m -Xmn128m\"\n```\n\n**bin/mqnamesrv.xml、bin/mqbroker.xml**\n\n修改前\n\n```xml\n<options>\n  <-Xms512m></-Xms512m>\n  <-Xmx1g></-Xmx1g>\n  <-XX:NewSize>256M</-XX:NewSize>\n  <-XX:MaxNewSize>512M</-XX:MaxNewSize>\n  <-XX:PermSize>128M</-XX:PermSize>\n  <-XX:MaxPermSize>128M</-XX:MaxPermSize>\n</options>\n```\n\n修改后\n\n```xml\n<options>\n  <-Xms256m></-Xms256m>\n  <-Xmx512m></-Xmx512m>\n  <-XX:NewSize>128M</-XX:NewSize>\n  <-XX:MaxNewSize>256M</-XX:MaxNewSize>\n  <-XX:PermSize>128M</-XX:PermSize>\n  <-XX:MaxPermSize>128M</-XX:MaxPermSize>\n</options>\n```\n\n#### 配置Nameserver\n\n分别启动Namserver01和Namserver02\n\n##### 启动Nameserver\n\n```shell\nnohup sh bin/mqnamesrv &\n```\n\n启动成功提示\n\n```shell\nThe Name Server boot success. serializeType=JSON\n```\n\n建议用supervisor管理进程，在后续博文中会详细介绍，本文先以nohup作为启动。\n\n##### 关闭Nameserver\n\n要先关闭Broker再关闭Nameserver\n\n```shell\nsh bin/mqshutdown namesrv\n```\n\n关闭成功提示\n\n```shell\nThe mqnamesrv(2418) is running...\nSend shutdown request to mqnamesrv(2418) OK\n```\n\n#### 配置Broker\n\n##### 编辑conf文件\n\n/rocketmq/conf/XXX.conf\n\n可参考conf下配置文件示例：2m-2s-async/、2m-2s-sync/、2m-noslave\n\n###### Broker-Master-01\n\n```yaml\n#namse server地址使用“;”\nnamesrvAddr=127.0.0.1:9876;192.168.2.183:9876\n#集群名称\nbrokerClusterName=DefaultCluster\n#master与slave的brokerName必须一致\nbrokerName=broker-01\n#0为master，大于0的brokerId为不同的slave\nbrokerId=0\n#在何时做过期消息删除默认凌晨4点\ndeleteWhen=04\n#在磁盘上保存消息的时间单位：小时\nfileReservedTime=48\n#SYNC_MASTER, ASYNC_MASTER, SLAVE\nbrokerRole=SYNC_MASTER\n#刷盘策略SYNC_FLUSH, ASYNC_FLUSH\nflushDiskType=ASYNC_FLUSH\n#Broker监听端口\nlistenPort=10911\n#存储消息目录\nstorePathRootDir=/Users/alanma/store-master-01\n```\n\n###### Broker-Slave-01\n\n```yaml\n#namse server地址使用“;”\nnamesrvAddr=127.0.0.1:9876;192.168.2.183:9876\n#集群名称\nbrokerClusterName=DefaultCluster\n#master与slave的brokerName必须一致\nbrokerName=broker-01\n#0为master，大于0的brokerId为不同的slave\nbrokerId=1\n#在何时做过期消息删除默认凌晨4点\ndeleteWhen=04\n#在磁盘上保存消息的时间单位：小时\nfileReservedTime=48\n#SYNC_MASTER, ASYNC_MASTER, SLAVE\nbrokerRole=SLAVE\n#刷盘策略SYNC_FLUSH, ASYNC_FLUSH\nflushDiskType=ASYNC_FLUSH\n#Broker监听端口\nlistenPort=10912\n#存储消息目录\nstorePathRootDir=/Users/alanma/store-slave-01\n```\n\n###### Broker-Master-02\n\n```yaml\n#namse server地址使用“;”\nnamesrvAddr=127.0.0.1:9876;192.168.2.183:9876\n#集群名称\nbrokerClusterName=DefaultCluster\n#master与slave的brokerName必须一致\nbrokerName=broker-02\n#0为master，大于0的brokerId为不同的slave\nbrokerId=0\n#在何时做过期消息删除默认凌晨4点\ndeleteWhen=04\n#在磁盘上保存消息的时间单位：小时\nfileReservedTime=48\n#SYNC_MASTER, ASYNC_MASTER, SLAVE\nbrokerRole=SYNC_MASTER\n#刷盘策略SYNC_FLUSH, ASYNC_FLUSH\nflushDiskType=ASYNC_FLUSH\n#Broker监听端口\nlistenPort=10913\n#存储消息目录\nstorePathRootDir=/Users/alanma/store-master-02\n```\n\n###### Broker-Slave-02\n\n```yaml\n#namse server地址使用“;”\nnamesrvAddr=127.0.0.1:9876;192.168.2.183:9876\n#集群名称\nbrokerClusterName=DefaultCluster\n#master与slave的brokerName必须一致\nbrokerName=broker-02\n#0为master，大于0的brokerId为不同的slave\nbrokerId=1\n#在何时做过期消息删除默认凌晨4点\ndeleteWhen=04\n#在磁盘上保存消息的时间单位：小时\nfileReservedTime=48\n#SYNC_MASTER, ASYNC_MASTER, SLAVE\nbrokerRole=SLAVE\n#刷盘策略SYNC_FLUSH, ASYNC_FLUSH\nflushDiskType=ASYNC_FLUSH\n#Broker监听端口\nlistenPort=10914\n#存储消息目录\nstorePathRootDir=/Users/alanma/store-slave-02\n```\n\n##### 启动broker\n\n./conf/broker-master.conf为配置文件名可以自定义\n\n```shell\nnohup sh ./bin/mqbroker -c ./conf/broker-master.conf &\n\nnohup sh ./bin/mqbroker -c ./conf/broker-slave.conf &\n```\n\n启动成功提示\n\n**查看日志**\n\n```shell\ntail -f ~/logs/rocketmqlogs/broker.log\n```\n\n```shell\nINFO PullRequestHoldService - PullRequestHoldService service started\nINFO main - register broker to name server 127.0.0.1:9876 OK\nINFO main - register broker to name server 192.168.2.183:9876 OK\nINFO main - The broker[broker-01, 192.168.2.134:10911] boot success. serializeType=JSON and name server is 127.0.0.1:9876;192.168.2.183:9876\nINFO BrokerControllerScheduledThread1 - dispatch behind commit log 0 bytes\nINFO BrokerControllerScheduledThread1 - Slave fall behind master: 745 bytes\nINFO BrokerControllerScheduledThread1 - register broker to name server 127.0.0.1:9876 OK\nINFO BrokerControllerScheduledThread1 - register broker to name server 192.168.2.183:9876 OK\nINFO BrokerControllerScheduledThread1 - register broker to name server 127.0.0.1:9876 OK\nINFO BrokerControllerScheduledThread1 - register broker to name server 192.168.2.183:9876 OK\nINFO BrokerControllerScheduledThread1 - dispatch behind commit log 0 bytes\nINFO BrokerControllerScheduledThread1 - Slave fall behind master: 745 bytes\nINFO BrokerControllerScheduledThread1 - register broker to name server 127.0.0.1:9876 OK\nINFO BrokerControllerScheduledThread1 - register broker to name server 192.168.2.183:9876 OK\n```\n\n##### 关闭broker\n\n要先关闭Broker再关闭Nameserver\n\n```shell\nsh bin/mqshutdown broker\n```\n\n#### 测试\n\n##### Producer\n\n```java\npackage com.mxw.doraemon.rocketmq;\n\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class Producer {\n\tpublic static void main(String[] args) throws MQClientException, InterruptedException {\n\n\t\tDefaultMQProducer producer = new DefaultMQProducer(\"ProducerGroupNameTest\");\n\t\tproducer.setNamesrvAddr(\"127.0.0.1:9876;192.168.2.183:9876\");\n\t\tproducer.setInstanceName(\"ProducerTest\");\n\t\tproducer.setVipChannelEnabled(false);\n\n\t\tproducer.start();\n\n\t\tfor (int i = 0; i < 1; i++) {\n\t\t\ttry {\n\t\t\t\t{\n\t\t\t\t\tMessage msg = new Message(\"q_test\", // topic\n\t\t\t\t\t\t\t\"TagA\", // tag\n\t\t\t\t\t\t\t\"OrderID001\", // key\n\t\t\t\t\t\t\t(\"Hello MetaQ TagA\").getBytes());// body\n\t\t\t\t\tSendResult sendResult = producer.send(msg);\n\t\t\t\t\tSystem.out.println(sendResult);\n\t\t\t\t}\n\n\t\t\t\t{\n\t\t\t\t\tMessage msg = new Message(\"q_test\", // topic\n\t\t\t\t\t\t\t\"TagB\", // tag\n\t\t\t\t\t\t\t\"OrderID0034\", // key\n\t\t\t\t\t\t\t(\"Hello MetaQ TagB\").getBytes());// body\n\t\t\t\t\tSendResult sendResult = producer.send(msg);\n\t\t\t\t\tSystem.out.println(sendResult);\n\t\t\t\t}\n\n\t\t\t\t{\n\t\t\t\t\tMessage msg = new Message(\"q_test\", // topic\n\t\t\t\t\t\t\t\"TagC\", // tag\n\t\t\t\t\t\t\t\"OrderID061\", // key\n\t\t\t\t\t\t\t(\"Hello MetaQ TagC\").getBytes());// body\n\t\t\t\t\tSendResult sendResult = producer.send(msg);\n\t\t\t\t\tSystem.out.println(sendResult);\n\t\t\t\t}\n\n\t\t\t\t{\n\t\t\t\t\tMessage msg = new Message(\"q_all_test\", (\"Hello MetaQ All~~~\").getBytes());\n\t\t\t\t\tSendResult sendResult = producer.send(msg);\n\t\t\t\t\tSystem.out.println(sendResult);\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tTimeUnit.MILLISECONDS.sleep(1000);\n\t\t}\n    \n\t\tproducer.shutdown();\n\t}\n}\n```\n\n**运行结果**\n\n```java\nSendResult [sendStatus=SEND_OK, msgId=C0A8028645EC135FBAA431C4CDD40000, offsetMsgId=C0A8028600002EED00000000000002E9, messageQueue=MessageQueue [topic=q_test, brokerName=broker-02, queueId=0], queueOffset=0]\nSendResult [sendStatus=SEND_OK, msgId=C0A8028645EC135FBAA431C4CDE50001, offsetMsgId=C0A8028600002EED00000000000003A8, messageQueue=MessageQueue [topic=q_test, brokerName=broker-02, queueId=1], queueOffset=0]\nSendResult [sendStatus=SEND_OK, msgId=C0A8028645EC135FBAA431C4CDE70002, offsetMsgId=C0A8028600002EED0000000000000468, messageQueue=MessageQueue [topic=q_test, brokerName=broker-02, queueId=2], queueOffset=0]\nSendResult [sendStatus=SEND_OK, msgId=C0A8028645EC135FBAA431C4CDEC0003, offsetMsgId=C0A8028600002EED0000000000000527, messageQueue=MessageQueue [topic=q_all_test, brokerName=broker-02, queueId=1], queueOffset=0]\n```\n\n##### Consumer\n\n```java\npackage com.mxw.doraemon.rocketmq;\n\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.common.message.MessageExt;\n\nimport java.util.List;\n\npublic class PushConsumer {\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\n\t\t\tDefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\"ConsumerGroupNameMXWLocalHost\");\n\t\t\tconsumer.setNamesrvAddr(\"127.0.0.1:9876;192.168.2.183:9876\");\n\t\t\tconsumer.setInstanceName(\"ConsumberMXW\");\n\t\t\tconsumer.setVipChannelEnabled(false);\n\n\t\t\t/**\n\t\t\t * 订阅指定topic下tags分别等于TagA或TagC或TagD\n\t\t\t */\n\t\t\tconsumer.subscribe(\"q_test\", \"TagA || TagC || TagD\");\n\n\t\t\tconsumer.subscribe(\"q_all_test\", \"*\");\n\n\t\t\tconsumer.registerMessageListener(new MessageListenerConcurrently() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,\n\t\t\t\t\t\tConsumeConcurrentlyContext context) {\n\t\t\t\t\tSystem.out.println(Thread.currentThread().getName() + \" Receive New Messages: \" + msgs.size());\n\n\t\t\t\t\tMessageExt msg = msgs.get(0);\n\t\t\t\t\tif (msg.getTopic().equals(\"q_test\")) {\n\t\t\t\t\t\t// 执行TopicTest1的消费逻辑\n\t\t\t\t\t\tif (msg.getTags() != null && msg.getTags().equals(\"TagA\")) {\n\t\t\t\t\t\t\t// 执行TagA的消费\n\t\t\t\t\t\t\tSystem.out.println(new String(msg.getBody()));\n\t\t\t\t\t\t} else if (msg.getTags() != null && msg.getTags().equals(\"TagC\")) {\n\t\t\t\t\t\t\t// 执行TagC的消费\n\t\t\t\t\t\t\tSystem.out.println(new String(msg.getBody()));\n\t\t\t\t\t\t} else if (msg.getTags() != null && msg.getTags().equals(\"TagD\")) {\n\t\t\t\t\t\t\t// 执行TagD的消费\n\t\t\t\t\t\t\tSystem.out.println(new String(msg.getBody()));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (msg.getTopic().equals(\"q_all_test\")) {\n\t\t\t\t\t\tSystem.out.println(new String(msg.getBody()));\n\t\t\t\t\t}\n\n\t\t\t\t\treturn ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconsumer.start();\n\n\t\t\tSystem.out.println(\"Consumer Started.\");\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n```\n\n**运行结果**\n\n```java\nConsumer Started.\nConsumeMessageThread_1 Receive New Messages: 1\nConsumeMessageThread_2 Receive New Messages: 1\nHello MetaQ TagA\nHello MetaQ TagC\nConsumeMessageThread_3 Receive New Messages: 1\nHello MetaQ All~~~\n```\n\n### 控制台\n\n​\t\tRocketMQ Console是官方扩展中的控制台，可以通过控制台图形界面实现大部分命令行运维操作，包括创建topic，修改queue数量，查看producer和consumer，查看队列堆积情况，查看集群信息，查询消息，手工发送消息等实用功能。\n\n#### 下载\n\n```shell\ngit clone git@github.com:apache/rocketmq-externals.git\n```\n\n#### 配置启动\n\n修改rocketmq-externals/rocketmq-console/src/main/resources/application.properties中端口号和Nameserver地址\n\n```yaml\n#端口号\nserver.port=8727\n#Nameserver地址\nrocketmq.config.namesrvAddr=127.0.0.1:9876;192.168.2.183:9876\n```\n\n**打包**\n\nrocketmq-externals/rocketmq-console\n\n```shell\nmvn clean -DskipTests package\n```\n\n**启动**\n\n```shell\njava -jar target/rocketmq-console-ng-1.0.0.jar\n```\n\n**地址**\n\n[http://127.0.0.1:8727](http://127.0.0.1:8727/)\n\n#### 集群信息\n\n<img src=\"mqconsole-001.png\" height=auto width=\"90%\">\n\n#### 创建Topic\n\n在实际生产环境，Topic的创建需要由运维人员提前手工创建，在集群环境，不要通过代码自动创建Topic，在创建Topic同步到各个Broker期间，如果进行消息的生产和消费，会引发后续一系列问题。\n\n<img src=\"mqconsole-002.jpg\" height=auto width=\"90%\">\n\n\n\n\n\n\n\n","tags":["RocketMQ"]},{"title":"mybatis-plus快速入门.md","url":"/2019/05/26/mybatis-plus快速入门/","content":"\n## 官网介绍\n\n[MyBatis-Plus](https://github.com/baomidou/mybatis-plus)（简称 MP）是一个 [MyBatis](http://www.mybatis.org/mybatis-3/) 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。\n\n详见[https://mp.baomidou.com](https://mp.baomidou.com/)\n\n## 使用感受\n\n使用mybatis-plus，在简单业务场景下，可以极大程度提高CRUD开发效率；在海量数据,复杂的多表级联查询场景下慎用分页插件中count方法获取总数量，容易造成数据库IO阻塞等问题，需要根据实际业务场景，进行SQL优化，不可简单的使用默认接口。\n\n## 快速入门\n\n### 环境准备\n\n- SpringBoot 2.2.0.M3\n- MyBatis-Plus 3.1.1\n- MySQL 5.7\n\n#### SQL脚本\n\n```sql\nDROP TABLE IF EXISTS user;\nCREATE TABLE user\n(\n\tid BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID',\n\tname VARCHAR(30) NULL DEFAULT NULL COMMENT '姓名',\n\tgender VARCHAR(20) NULL DEFAULT NULL COMMENT '性别',\n\tage INT(11) NULL DEFAULT NULL COMMENT '年龄',\n\temail VARCHAR(50) NULL DEFAULT NULL COMMENT '邮箱',\n\tPRIMARY KEY (id)\n);\nDELETE FROM user;\nINSERT INTO user (name,gender,age, email) VALUES\n('Jone','MALE' ,18, 'test1@baomidou.com'),\n( 'Jack', 'MALE' ,20, 'test2@baomidou.com'),\n( 'Tom', 'MALE' ,28, 'test3@baomidou.com'),\n( 'Sandy','FEMALE' , 21, 'test4@baomidou.com'),\n( 'Billie', 'MALE' ,24, 'test5@baomidou.com');\n```\n\n### 配置\n\n#### pom.xml\n\n一定要依赖jsqlparser，否则在使用分页插件时会报错java.lang.NoClassDefFoundError: net/sf/jsqlparser/expression/Expression导致java.lang.NoClassDefFoundError: Could not initialize class com.baomidou.mybatisplus.extension.plugins.pagination.optimize.JsqlParserCountOptimize \n\n```xml\n\t\t\t\t<dependency>\n            <groupId>com.baomidou</groupId>\n            <artifactId>mybatis-plus-boot-starter</artifactId>\n            <version>3.1.1</version>\n        </dependency>\n\t\t\t\t<dependency>\n            <groupId>com.github.jsqlparser</groupId>\n            <artifactId>jsqlparser</artifactId>\n            <version>2.0</version>\n        </dependency>\n\t\t\t\t<dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>com.baomidou</groupId>\n            <artifactId>mybatis-plus-generator</artifactId>\n            <version>3.1.1</version>\n        </dependency>\n        <dependency>\n            <groupId>org.freemarker</groupId>\n            <artifactId>freemarker</artifactId>\n            <version>2.3.28</version>\n        </dependency>\n```\n\n#### application.yml\n\n```yaml\nmybatis-plus:\n  #在多工程项目中建议使用classpath*配置（即加载多个 jar 包下的 XML 文件）\n  mapper-locations: classpath*:/mapper/**/*.xml\n  #实体类包路径,不要配置为父级包路径，会导致启动加载时出现错误The alias 'xxx' is already mapped to the value 'com.xxx.xxx'\n  typeAliasesPackage: com.mxw.doraemon.entity\n  #枚举属性对应的包路径\n  typeEnumsPackage: com.mxw.doraemon.entity.enums\n  global-config:\n    #主键类型  0:\"数据库ID自增\", 1:\"用户输入ID\",2:\"全局唯一ID (数字类型唯一ID)\", 3:\"全局唯一ID UUID\";\n    id-type: 0\n    #字段策略 0:\"忽略判断\",1:\"非 NULL 判断\"),2:\"非空判断\"\n    field-strategy: 2\n    db-column-underline: true\n    refresh-mapper: true\n    logic-delete-value: 0\n    logic-not-delete-value: 1\n  configuration:\n    map-underscore-to-camel-case: true\n    cache-enabled: false\n```\n\n对于`IDEA`系列编辑器，XML 文件是不能放在 java 文件夹中的，IDEA 默认不会编译源码文件夹中的 XML 文件，可以参照以下方式解决：\n\n- 将配置文件放在 resource 文件夹中\n- 对于 Maven 项目，可指定 POM 文件的 resource\n\n```xml\n<build>\n  <resources>\n      <resource>\n          <!-- xml放在java目录下-->\n          <directory>src/main/java</directory>\n          <includes>\n              <include>**/*.xml</include>\n          </includes>\n      </resource>\n      <!--指定资源的位置（xml放在resources下，可以不用指定）-->\n      <resource>\n          <directory>src/main/resources</directory>\n      </resource>\n  </resources>\n</build>\n```\n\n#### MapperScan注解\n\n```java\n@EnableTransactionManagement\n@Configuration\n@MapperScan(\"com.mxw.doraemon.mapper\")\npublic class MybatisPlusConfig {\n\t/**\n\t * 分页拦截器\n\t * @return\n\t */\n\t@Bean\n\tpublic PaginationInterceptor paginationInterceptor() {\n\t\treturn new PaginationInterceptor();\n\t}\n\n}\n```\n\n### 编码\n\n#### Entity\n\n使用*Lombok*优雅的编写Bean，通过注解无需再通过IDE工具生成构造方法和get/set方法，可以在开发中直接调用Bean的set/get方法。下方构造方法是因为测试代码需要而写，可以忽略。\n\n##### User\n\n```java\n@Data\n@EqualsAndHashCode(callSuper = true)\n@Accessors(chain = true)\npublic class User extends BaseEntity {\n\n\tprivate static final long serialVersionUID = 125341736548392818L;\n\n\t/**\n\t * 姓名\n\t */\n\tprivate String name;\n\n\t/**\n\t * 性别\n\t */\n\tprivate GenderEnum gender;\n\n\t/**\n\t * 年龄\n\t */\n\tprivate Integer age;\n\n\t/**\n\t * 邮箱\n\t */\n\tprivate String email;\n\n\tpublic User() {\n\t\tsuper();\n\t}\n\n\tpublic User(String name, GenderEnum gender, Integer age, String email) {\n\t\tthis.name = name;\n\t\tthis.gender = gender;\n\t\tthis.age = age;\n\t\tthis.email = email;\n\t}\n}\n```\n\n##### BaseEntity\n\n```java\n@Data\n@Accessors(chain = true)\npublic class BaseEntity {\n\n  @TableId(type = IdType.AUTO)\n  private Long id;\n\n}\n```\n\n#### Enums\n\n```java\npublic enum GenderEnum implements IEnum {\n    MALE(\"MALE\", \"男\"),\n    FEMALE(\"FEMALE\", \"女\"),;\n  \n    private String value;\n    private String desc;\n\n    GenderEnum(final String value, final String desc) {\n        this.value = value;\n        this.desc = desc;\n    }\n\n    @Override\n    public Serializable getValue() {\n        return this.value;\n    }\n\n    @JsonValue\n    public String getDesc(){\n        return this.desc;\n    }\n}\n```\n\n#### Mapper Interface\n\nBaseMapper接口已包含常用CRUD方法，例如：根据主键ID查询，根据实体条件查询，根据条件器封装复杂条件查询，根据主键更新属性，根据主键删除实体等常用操作，所以这里只需写业务需要的复杂接口即可。\n\n```java\npublic interface UserMapper extends BaseMapper<User> {\n  \n   List<User> getByNameSQLXML(@Param(\"name\") String name);\n  \n   @Select(\"select * from user where name ='${name}'\")\n   List<User> getByNameSQL(@Param(\"name\") String name);\n}\n```\n\n#### Mapper XML\n\nmybatis-plus兼容mybatis原生功能，依然可以在XML中写SQL\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" >\n<mapper namespace=\"com.mxw.doraemon.mapper.UserMapper\">\n    <resultMap id=\"user\" type=\"com.mxw.doraemon.entity.User\"/>\n    <parameterMap id=\"user\" type=\"com.mxw.doraemon.entity.User\"/>\n    \n    <select id=\"getByNameSQLXML\" resultMap=\"user\" parameterType=\"java.lang.String\">\n        SELECT  * FROM USER where name= #{name,jdbcType=VARCHAR}\n    </select>\n    \n</mapper>\n\n```\n\n#### Controler\n\n最好在Mapper接口层之上，再封装一层Service适配层，这样即使项目更换持久层技术，可以保证不影响主业务逻辑代码；在Service层可以添加@Transaction事务注解，直接在方法上添加事物注解，会因为spring bean代理机制，导致事务不生效；这里为了方便演示测试，直接在Controler里以Get请求调用Mapper，对数据库进行操作。\n\n```java\n@RestController\n@RequestMapping(\"/user\")\npublic class UserController {\n\n\t@Autowired\n\tprivate UserMapper userMapper;\n\n\n\t/**\n\t * 创建用户\n\t * http://localhost:8726/user/createUser?name=alan&gender=MALE&age=18&email=alanxiaowei@hotmail.com\n\t *\n\t * @param name\n\t * @return\n\t */\n\t@GetMapping(\"/createUser\")\n\tpublic String createUser(String name,String gender,Integer age,String email) {\n\t\tUser user = new User(name,GenderEnum.valueOf(gender),age,email);\n\n\t\tInteger index = userMapper.insert(user);\n\t\tif (index > 0) {\n\t\t\treturn \"已创建用户:\"+user.toString();\n\t\t} else {\n\t\t\treturn \"创建用户失败\";\n\t\t}\n\t}\n\n\t/**\n\t * 根据编号查询用户信息\n\t * http://localhost:8726/user/getUserById?userId=1\n\t *\n\t * @param userId\n\t * @return\n\t */\n\t@GetMapping(\"/getUserById\")\n\tpublic User getUserById(Integer userId) {\n\t\treturn userMapper.selectById(userId);\n\t}\n\n\t/**\n\t * 根据名称查询用户信息（Mybatis方式执行XML配置文件中SQL）\n\t * http://localhost:8726/user/geUserByName1?name=alan\n\t *\n\t * @return\n\t */\n\t@GetMapping(\"/geUserByName1\")\n\tpublic List<User> getUserByNameXML(String name) {\n\t\treturn userMapper.getByNameSQLXML(name);\n\t}\n\n\n\t/**\n\t * 根据名称查询用户信息（MyBatisPlus Map条件方式）\n\t * http://localhost:8726/user/geUserByName2?name=alan\n\t *\n\t * @param userName\n\t * @return\n\t */\n\t@GetMapping(\"/geUserByName2\")\n\tpublic List<User> getUserByNameMap(String name) {\n\t\tMap map = new HashMap();\n\t\tmap.put(\"name\", name);\n\t\treturn userMapper.selectByMap(map);\n\t}\n\n\t/**\n\t * 根据名称查询用户信息（MyBatisPlus方式执行mapper注解中SQL）\n\t * http://localhost:8726/user/geUserByName3?name=alan\n\t *\n\t * @param userName\n\t * @return\n\t */\n\t@GetMapping(\"/geUserByName3\")\n\tpublic List<User> getUserListByNameSQL(String name) {\n\t\treturn userMapper.getByNameSQL(name);\n\t}\n\n\t/**\n\t * 分页查询用户列表\n\t * http://localhost:8726/user/getList?pageNumber=1&pageSize=2\n\t *\n\t * @param pageNumber\n\t * @param pageSize\n\t * @return\n\t */\n\t@GetMapping(\"/getList\")\n\tpublic List<User> getList(Integer pageNumber, Integer pageSize) {\n\t\tIPage<User> page = new Page<>(pageNumber, pageSize);\n\t\treturn userMapper.selectPage(page,null).getRecords();\n\t}\n\n\t/**\n\t * 修改用户\n\t * http://localhost:8726/user/updateUser?name=alan&age=32\n\t *\n\t * @param id\n\t * @param userName\n\t * @param userPassword\n\t * @return\n\t */\n\t@GetMapping(\"/updateUser\")\n\tpublic String updateUser(String name, Integer age) {\n\t\tQueryWrapper wrapper = new QueryWrapper<User>();\n\t\twrapper.eq(\"name\", name);\n\t\tUser user = userMapper.selectOne(wrapper);\n\t\tuser.setAge(age);\n\t\tInteger index = userMapper.updateById(user);\n\t\tif (index > 0) {\n\t\t\treturn \"已修改用户信息：\" + user.toString();\n\t\t} else {\n\t\t\treturn \"修改用户失败\";\n\t\t}\n\t}\n\n\t/**\n\t * 删除用户\n\t * http://localhost:8726/user/deleteUser?name=alan\n\t *\n\t * @param id\n\t * @param userName\n\t * @param userPassword\n\t * @return\n\t */\n\t@GetMapping(\"/deleteUser\")\n\tpublic String deleteUser(String name) {\n\t\tQueryWrapper wrapper = new QueryWrapper<User>();\n\t\twrapper.eq(\"name\", name);\n\t\tUser user = userMapper.selectOne(wrapper);\n\t\tInteger index = userMapper.deleteById(user.getId());\n\t\tif (index > 0) {\n\t\t\treturn \"已删除用户：\" + user.toString();\n\t\t} else {\n\t\t\treturn \"删除用户失败\";\n\t\t}\n\t}\n}\n```\n\n### Junit测试\n\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class UserTest {\n   @Autowired\n   private UserMapper userMapper;\n   @Test\n   public void testSelect() {\n      List<User> userList = userMapper.getByNameSQLXML(\"alan\");\n      userList.forEach(System.out::println);\n   }\n}\n\n```\n\n### 自动生成代码\n\n通过 MysqlGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率，MyBatis-Plus 从 `3.0.3` 之后移除了代码生成器与模板引擎的默认依赖，需要手动添加相关依赖：mybatis-plus-generator，使用前请修改项目的数据源连接信息。\n\n```java\npublic class MysqlGenerator {\n\n    static final String OUT_PUT_DIR = \"/doraemon/src/main/java\";\n    static final String AUTHOR =\"Alan Ma\";\n    static final String DB_URL = \"jdbc:mysql://localhost:3306/test?useUnicode=true&useSSL=false&characterEncoding=utf8\";\n    static final String USER_NAME =\"root\";\n    static final String PASSWORD =\"password\";\n    static final String PARENT_PACKAGE = \"com.mxw.doraemon\";\n    static final String SUPER_ENTITY_CLASS=PARENT_PACKAGE+\".common.BaseEntity\";\n    static final String SUPER_CONTROLLER_CLASS = PARENT_PACKAGE + \".common.BaseController\";\n    static final String MAPPER_PATH = \"/doraemon/src/main/resources/mapper/\";\n    /**\n     * <p>\n     * 读取控制台内容\n     * </p>\n     */\n    public static String scanner(String tip) {\n        Scanner scanner = new Scanner(System.in);\n        StringBuilder help = new StringBuilder();\n        help.append(\"请输入\" + tip + \"：\");\n        System.out.println(help.toString());\n        if (scanner.hasNext()) {\n            String ipt = scanner.next();\n            if (StringUtils.isNotEmpty(ipt)) {\n                return ipt;\n            }\n        }\n        throw new MybatisPlusException(\"请输入正确的\" + tip + \"！\");\n    }\n\n    /**\n     * RUN THIS\n     */\n    public static void main(String[] args) {\n        // 代码生成器\n        AutoGenerator mpg = new AutoGenerator();\n\n        // 全局配置\n        GlobalConfig gc = new GlobalConfig();\n        String projectPath = System.getProperty(\"user.dir\");\n        gc.setOutputDir(projectPath + OUT_PUT_DIR);\n        gc.setAuthor(AUTHOR);\n        gc.setOpen(false);\n        mpg.setGlobalConfig(gc);\n\n        // 数据源配置\n        DataSourceConfig dsc = new DataSourceConfig();\n        dsc.setUrl(DB_URL);\n        // dsc.setSchemaName(\"public\");\n        dsc.setDriverName(\"com.mysql.jdbc.Driver\");\n        dsc.setUsername(USER_NAME);\n        dsc.setPassword(PASSWORD);\n        mpg.setDataSource(dsc);\n\n        // 包配置\n        PackageConfig pc = new PackageConfig();\n        pc.setModuleName(scanner(\"模块名\"));\n        pc.setParent(PARENT_PACKAGE);\n        mpg.setPackageInfo(pc);\n\n        // 自定义配置\n        InjectionConfig cfg = new InjectionConfig() {\n            @Override\n            public void initMap() {\n                // to do nothing\n            }\n        };\n        List<FileOutConfig> focList = new ArrayList<>();\n        focList.add(new FileOutConfig(\"/templates/mapper.xml.ftl\") {\n            @Override\n            public String outputFile(TableInfo tableInfo) {\n                // 自定义输入文件名称\n                return projectPath + MAPPER_PATH + pc.getModuleName()\n                        + \"/\" + tableInfo.getEntityName() + \"Mapper\" + StringPool.DOT_XML;\n            }\n        });\n        cfg.setFileOutConfigList(focList);\n        mpg.setCfg(cfg);\n        mpg.setTemplate(new TemplateConfig().setXml(null));\n\n        // 策略配置\n        StrategyConfig strategy = new StrategyConfig();\n        strategy.setNaming(NamingStrategy.underline_to_camel);\n        strategy.setColumnNaming(NamingStrategy.underline_to_camel);\n        strategy.setSuperEntityClass(SUPER_ENTITY_CLASS);\n        strategy.setEntityLombokModel(true);\n        strategy.setSuperControllerClass(SUPER_CONTROLLER_CLASS);\n        strategy.setInclude(scanner(\"表名\"));\n        strategy.setSuperEntityColumns(\"id\");\n        strategy.setControllerMappingHyphenStyle(true);\n        strategy.setTablePrefix(pc.getModuleName() + \"_\");\n        mpg.setStrategy(strategy);\n        // 选择 freemarker 引擎需要指定如下加，注意 pom 依赖必须有！\n        mpg.setTemplateEngine(new FreemarkerTemplateEngine());\n        mpg.execute();\n    }\n}\n```","tags":["Mybatis-Plus"],"categories":["Mybatis-Plus"]}]